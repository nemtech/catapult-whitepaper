\section{Cryptography}
\label{sec:cryptography}

\nemquote{%
I understood the importance in principle of public key cryptography but it's all moved much faster than I expected. I did not expect it to be a mainstay of advanced communications technology.
}{Whitfield Diffie}

\nemchapterfirstletter{B}{lockchain} technology demands the use of some cryptographic concepts.
\codenamespace uses cryptography based on Elliptic Curve Cryptography (ECC).
The choice of the underlying curve is important in order to guarantee security and speed.

\codenamespace uses the Ed25519\index{Ed25519} digital signature algorithm.
This algorithm uses the following \emph{Twisted Edwards curve}:
$$ -x^2 + y^2 = 1 - \frac{121665}{121666} x^2 y^2$$
over the finite field defined by the prime number $2^{255}-19$.
The base point for the corresponding group G is called B.
The group has $q=2^{252} + 27742317777372353535851937790883648493$ elements.
It was developed by D. J. Bernstein et al. and is one of the safest and fastest digital signature algorithms \cite{Bernstein2011}.

Importantly for \codenamespace purposes, the algorithm produces short 64-byte signatures and supports fast signature verification.
Neither key generation nor signing is used during block processing, so the speed of these operations is unimportant.

\subsection{Public/Private Key Pair}
\index{key!private}
\index{key!public}

A \emph{private key} is a random 256-bit integer $k$. To derive the public key\emph{public key} \underline{A} from it, the following steps are taken:
\begin{align}
	\hf(k) &=(h_0, h_1, \ldots, h_{511}) \\
	a &= 2^{254} + \sum_{3\leq i \leq 253} 2^i h_i \\
	A &= aB
\end{align}

Since $A$ is a group element, it can be encoded into a 256-bit integer \underline{A}, which serves as the public key.

\subsection{Signing and Verification}

Given a message $M$, private key $k$ and its associated public key \underline{A}, the following steps are taken to create a signature:
\begin{align}
	\hf(k) &=(h_0, h_1, \ldots, h_{511}) \\
	r &= \hf(h_{256}, \ldots, h_{511}, M) \text{ where the comma means concatenation} \\
	R &= rB \\
	S &= (r + \hf(\underline{R}, \underline{A}, M)a) \: mod \: q \label{eq:cryptography:S}
\end{align}

Then $(\underline{R}, \underline{S})$ is the \nind{signature} for the message $M$ under the private key $k$.
Note that only signatures where $S<q$ and $S>0$ are considered as valid \textbf{to prevent} the problem of \emph{signature malleability}\index{signature!malleability}.

To verify the signature $(\underline{R}, \underline{S})$ for the given message $M$ and public key \underline{A}, the verifier checks $S<q$ and $S>0$ and then calculates
\begin{align*}
	\tilde{R} = SB - \hf(\underline{R}, \underline{A}, M)A
\end{align*}

and verifies that
\begin{equation}
	\tilde{R} = R \label{eq:cryptography:verifyR}
\end{equation}

If $S$ was computed as shown in \eqref{eq:cryptography:S} then
$$SB = rB + (\hf(\underline{R}, \underline{A}, M)a)B = R + \hf(\underline{R}, \underline{A}, M)A$$
so \eqref{eq:cryptography:verifyR} will hold.

\subsubsection{Batch Verification}

When lots of signatures have to be verified, a batch signature verification can speed up the process by about 80\%.
\codenamespace uses the algorithm outlined in \cite{Bernstein2011}.
Given a batch of $(M_i, A_i, R_i, S_i)$ where $(R_i, S_i)$ is the signature for the message $M_i$ with public key $A_i$,
let $H_i = \hf(R_i, A_i, M_i)$.
Additionally, assume a corresponding number of uniform distributed 128-bit independent random integers $z_i$ are generated.
Now consider the equation:
\begin{align}
	\left(-\sum_i{z_i S_i \: \mathrm{mod} \: q}\right)B + \sum_i{z_i R_i} + \sum_i{(z_i H_i \: \mathrm{mod} \: q)A_i = 0} \label{eq:cryptography:verifyBatch}
\end{align}

Setting $P_i = 8 R_i + 8 H_i A_i - 8 S_i B$, then if \eqref{eq:cryptography:verifyBatch} holds, it implies
\begin{align}
	\sum_i{z_i P_i} = 0 \label{eq:cryptography:verifyBatch2}
\end{align}

All $P_i$ are elements of a cyclic group (remember $q$ is a prime).
If some $P_i$ is not zero, for example $P_2$, it means that for given integers $z_0, z_1, z_3, z_4 \ldots$, there is exactly one choice for $z_2$ to satisfy \eqref{eq:cryptography:verifyBatch2}.
The chance for that is $2^{-128}$.
Therefore, if \eqref{eq:cryptography:verifyBatch} holds, it is a near certainty that $P_i = 0$ for all $i$.
This implies that the signatures are valid.

If \eqref{eq:cryptography:verifyBatch} does not hold, it means that there is at least one invalid signature.
In that case, \codenamespace falls back to single signature verification to identify the invalid signatures.

\subsection{Verifiable Random Function (VRF)}
\label{sec:cryptography:vrf}

A verifiable random function (\nind{VRF}) uses a public/private key pair to generate pseudo-random values.
Only the owner of the private key can generate a value such that it cannot be predetermined by an adversary.
Anyone with the public key can verify whether or not the value was generated by its associated private key.
\codenamespace uses the ECVRF-EDWARDS25519-SHA512-TAI defined in \cite{irtf-cfrg-vrf-07}.

To generate a proof\footnote{
	This is typically called proving, not to be confused with verifying, because the private key owner needs to prove that it generated
	the random value with its private key.
} given a public key $Y$ corresponding to a private key $SK = xB$ and an input seed $alpha$\footnote{
	The listings provided in this section do not define auxiliary functions.
	Full descriptions of these functions can be found in \cite{irtf-cfrg-vrf-07}.
}:
\begin{align*}
	H &= \mathfunc{map\_to\_group\_element}(alpha, Y) \\
	\gamma &= xH \\
	k &= \mathfunc{generate\_nonce}(H) \\
	c &= \mathfunc{IetfHash}(3, 2, H, \gamma, kB, kH)[0..15] \\
	s &= (k + cx) \mod q \\
	proof &= (\gamma, c, s)
\end{align*}

The proof produced by the function above can be verified with the following procedure:
\begin{align*}
	H &= \mathfunc{map\_to\_group\_element}(alpha, Y) \\
	U &= sB - cY \\
	V &= sH - c \gamma \\
	\mathvar{verification\_hash} &= \mathfunc{IetfHash}(3, 2, H, \gamma, U, V)[0..15]
\end{align*}

When the calculated $\mathvar{verification\_hash}$ matches the $c$ part of the proof, the verification of the random value is successful.

A proof hash, also called a VRF hash output, can be derived from $\gamma$ of a \emph{validated} proof:
\begin{align}
	\mathvar{proof\_hash} &= \mathfunc{IetfHash}(3, 3, 8 \gamma) \label{eq:cryptography:proofHash}
\end{align}

\subsection{Voting Key Tree}
\label{sec:cryptography:voting}
\index{tree!BM (Bellare-Miner)}
\index{BM tree|see {tree, BM (Bellare-Miner)}}

Finalization voters are required to specify the range of epochs in which a root voting key is eligible to vote.
Prior to announcing a root voting key, voters are required to build a voting key tree that contains epoch-pinned voting keys.
The tree construction is roughly based on Bellare-Miner \cite{BellareMiner1999} construction.

A two-level tree is used in the current implementation.
The amount of keys in the lowest level is dependent on the \nemsetting{finalization}{votingKeyDilution} setting\footnote{
	This setting must be the same across all network nodes.
}.

\newcommand{\key}[1]{ node { $sk_{#1}$ \\ $pk_{#1}$ \\ $sig_{#1}$ } }
\begin{figure}[h]
	\nemcenterwithcaption{
		\begin{tikzpicture}[font=\small,every node/.style = {shape=rectangle, rounded corners, draw, align=center}]]
		\tikzset{
			used/.style = { text=gray!30 },
			unused/.style = { text=black },
		}
		\tikzstyle{level 1}=[level distance=10em]
		\tikzstyle{level 2}=[level distance=6em]
		\node { root voting public key }
			child [used, sibling distance=15em] { \key{b_1}
				child [sibling distance=4em] { \key{b_{1,0}} }
				child [sibling distance=4em] { \key{b_{1,1}} }
				child [unused, sibling distance=1.5em] { node[draw=none] { \ldots } }
				child [sibling distance=3em] { \key{b_{1,d-1}} }
			}
			child [used, sibling distance=15em] { \key{b_2}
				child [used, sibling distance=4em] { \key{b_{2,0}} }
				child [unused, sibling distance=4em] { \key{b_{2,1}} }
				child [unused, sibling distance=1.5em] { node[draw=none] { \ldots } }
				child [unused, sibling distance=3em] { \key{b_{2,d-1}} }
			}
			child [sibling distance=2em] { node[draw=none] { \vdots } }
			child [sibling distance=3em] { \key{b_n}
				child [used] { node { sub-tree \\ not ready } }
			};
		\end{tikzpicture}
	}{Voting key tree with $d := \nemsetting{finalization}{votingKeyDilution}$ }
\end{figure}

The tree is built by pinning keys to identifiers in the tree. The identifiers in the tree are derived from the epoch.
\begin{align}
	i &= \mathfunc{floor}(\mathvar{epoch} / \nemsetting{finalization}{votingKeyDilution}) \\
	j &= \mathvar{epoch} \bmod \nemsetting{finalization}{votingKeyDilution}
\end{align}

$i$ is an index into the middle layer of the tree relative to the root.
$j$ is an index into the bottom layer of the tree relative to the middle layer.
$b_i$ is an index from the root to the \emph{i} middle layer.
$b_{i,j}$ is an index from the root to the \emph{i} middle layer and from there to the \emph{j} bottom layer.

The tree is partially built before announcing a voting key link transaction.
First, the \emph{tree root key pair} is generated.
The root public key is signed with an account's signing public key as part of the voting key link transaction.

Next, middle-level keys are generated and, for each key pair, the public key is signed with the root key.
After all middle-level keys are generated, the \emph{root secret key} is discarded.
\begin{align*}
	\mathvar{sig}_{b_i} &= \mathfunc{Sign}_{\mathname{root secret key}}(\mathvar{pk}_{b_i} || \mathfunc{IntToBin}(i))
\end{align*}

When requested, a batch of \nemsetting{finalization}{votingKeyDilution} bottom-level keys are generated in a similar fashion.
When the batch is generated, the middle-level secret key is discarded.
\begin{align*}
	\mathvar{sig}_{b_{i,j}} &= \mathfunc{Sign}_{\mathvar{sk}_{b_i}}(\mathvar{\mathvar{pk}_{b_{i, j}} || \mathfunc{IntToBin}(j) })
\end{align*}

\index{key!BM tree signing}

Therefore, every \emph{BM tree signing key} is composed of three parts:
\begin{itemize}
	\item{top-level: $\mathname{root voting public key}$}
	\item{middle-level: $(\mathvar{pk}_{b_i}, \mathvar{sig}_{b_i})$}
	\item{bottom-level: $(\mathvar{sk}_{b_i, j}, \mathvar{pk}_{b_i, j}, \mathvar{sig}_{b_i})$}
\end{itemize}

A bottom-level key is only valid for a single epoch, and then it is discarded.
When in use, all the higher level keys that have generated the bottom level key have already been destroyed.
Using a unique short-term key for each epoch prevents long range attacks revolving around an attacker collecting old and discarded finalization keys.

When signing a voting message for a given epoch, a bottom-level signature is created:
\begin{align*}
	\mathvar{sig}_{\mathname{message-i,j}} &= \mathfunc{Sign}_{\mathvar{sk}_{b_{i,j}}}(message)
\end{align*}

\index{signature!BM tree}

Finally, the signature for a vote in a given epoch - called \emph{BM tree signature} - is composed of three pairs:
\begin{itemize}
	\item{$(\mathname{root voting public key}, \mathvar{sig}_{b_i} )$}
	\item{$(\mathvar{pk}_{b_i}, \mathvar{sig}_{b_{i, j}})$}
	\item{$(\mathvar{pk}_{b_{i,j}}, \mathvar{sig}_{\mathname{message-i,j}})$}
\end{itemize}

A \emph{BM tree signature} is considered verified when:
\begin{itemize}
	\item{\emph{root voting public key} is registered to participate in the given epoch.}
	\item{\emph{middle-level} and \emph{bottom-level} keys match epoch.}
	\item{All component signatures are cryptographically verified.}
\end{itemize}
